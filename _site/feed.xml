<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daisydan</title>
    <description>前端开发工程师一枚！</description>
    <link>https://dandanzhou.github.io/</link>
    <atom:link href="https://dandanzhou.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 09 Mar 2016 20:59:18 +0800</pubDate>
    <lastBuildDate>Wed, 09 Mar 2016 20:59:18 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>url从浏览器输入到页面呈现</title>
        <description>&lt;h2 id=&quot;url&quot;&gt;url从浏览器输入到页面呈现&lt;/h2&gt;

&lt;p&gt;前段时间有人问我“从输入URL到页面加载完成的过程中都发生了什么”，当时脑袋里的碎片零零散散，就是不知道怎样完整的回答，今天刚好有时间把它给好好整理整理。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要的流程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;DNS解析--&amp;gt;建立连接，发送数据包 --&amp;gt;服务器响应请求，返回给浏览器--&amp;gt;浏览器渲染程序页面。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DNS解析&lt;br /&gt;
首先在浏览器输入了一个URL地址，但URL中服务器地址是一个域名而不是一个指定的IP地址，路由器并不知道你想要查找的地址，那么DNS域名解析系统会将该域名解析成ip，而IP地址是唯一的， 每一个ip地址对应网络上的一台计算机。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建立网络连接，发送数据包&lt;br /&gt;
 由于以上的努力，已经能够根据ip和端口号与网络上对应的服务器建立连接，浏览器这边会向服务器发送一个数据包，里面包含了大量的信息，但这个数据包有一定的格式。就像我给你邮个快递，也得遵循邮递公司的一些规则吧！我得写上我的身份信息、寄的物品、标明邮递地址….道理是一样的，到了网络中这些规则就是“Http协议(网络协议)”。&lt;br /&gt;
 http协议是客户端和服务器端两者通信共同遵循的一些规则。主要内容是定义了客户端如何向服务器请求资源，服务器如何响应客户端请求。&lt;br /&gt;
  请求中的POST与 GET方法有什么区别？&lt;br /&gt;
  1.根据HTTP规范，GET用于信息获取，而且应该是安全的,这里的安全是指非修改的信息，就像在数据库执行查询一样，不会修改数据，也不会增加删减数据，不会影响资源的状态，而post可能会改变数据的原始状态。&lt;br /&gt;
  2.GET提交的数据最多只有1024字节，理论上POST是没有限制的。&lt;br /&gt;
  3.从请求的URL中可以找到一个区别：GET请求的数据会附在URL之后，在浏览器URL栏就能看的。似乎POST比GET更可靠一些，因为它请求把提交的数据放在包体中，地址栏上不可见。（也有的解释说两者都没有长度限制，根本的区别就是一个是获取数据，一个修改数据！）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务器响应请求，返回给浏览器&lt;br /&gt;
服务器会分解你的数据包，例如你查找的是一个文档，那么服务器可能会返回一个doc文档或者zip压缩资源给你；如果你访问的是一个链接页面，那么服务器相应的返回一个包含HTML/CSS标记文档，这些请求和响应都有一个通用的写法，这些规则也就是前面提到的”http协议”。&lt;br /&gt;
客户端向服务器请求资源时，除了告诉服务器要请求的资源，同时还会附带一些其他的信息，这部分信息放在”header”部分（服务器响应请求也一样！），主要有请求头(略)和响应头&lt;/p&gt;

    &lt;p&gt;200	OK	一切正常，对GET和POST请求的应答文档跟在后面。&lt;br /&gt;
  201	Created	服务器已经创建了文档，Location头给出了它的URL。&lt;br /&gt;
  202	Accepted	已经接受请求，但处理尚未完成。&lt;/p&gt;

    &lt;p&gt;300	Multiple Choices	客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。&lt;br /&gt;
  301	Moved Permanently	永久重定向。&lt;br /&gt;
  302	Found	临时重定向&lt;br /&gt;
  304	Not Modified	客户端有缓冲的文档并发出了一个条件性的请求。服务器告 诉客户，原来缓冲的文档还可以继续使用。&lt;/p&gt;

    &lt;p&gt;400	Bad Request	请求出现语法错误。&lt;br /&gt;
  403	Forbidden	资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。&lt;br /&gt;
  404	Not Found	无法找到指定位置的资源。这也是一个常用的应答。&lt;br /&gt;
  405	Method Not Allowed	请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）&lt;/p&gt;

    &lt;p&gt;500	Internal Server Error	服务器遇到了意料不到的情况，不能完成客户的请求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;客户端渲染&lt;br /&gt;
  渲染引擎得到html字符串作为输入，然后对html进行转换，转化成能够被DOM处理的形式，接着转换成一个dom树，在解析html的过程，解析到link、script、img等一些请求标签时，会发送请求把对应的内容获取到。这时又会同步进行css的解析，构建出css样式规则应用到dom树上，然后进行一定的布局处理，比如标记节点块在浏览器中的坐标等形成最终的渲染树，最后根据这棵渲染树在浏览器窗口中进行绘制。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 10 Mar 2016 04:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8-URL/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/03/10/%E6%B5%8F%E8%A7%88%E5%99%A8-URL/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>Js常用正则</title>
        <description>&lt;h2 id=&quot;js&quot;&gt;Js常用正则&lt;/h2&gt;
&lt;p&gt;前端开发中总避免不了使用一些正则表达式来处理一些问题，下面就列常用的几例&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符串去重&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var str = &quot;adsfjjbkk&quot;;  
// \1匹配第一个子串  
// 只去除连续重复  
console.log(str.replace(/(.)(\1)+/g,function($1,$2,$3){  
    return $2;  
}));// adsfjbk
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;js获取URL中的参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function GetQueryString(name) {
    var reg = new RegExp(&quot;(^|&amp;amp;)&quot; + name + &quot;=([^&amp;amp;]*)(&amp;amp;|$)&quot;, &quot;i&quot;);
    var r = window.location.search.substr(1).match(reg); //获取url中&quot;?&quot;符后的字符串并正则匹配
    var context = &quot;&quot;;
    if (r != null)
    context = r[2];
    reg = null;
    r = null;
    return context == null || context == &quot;&quot; || context == &quot;undefined&quot; ? &quot;&quot; : context;
}
alert(GetQueryString(&quot;q&quot;));
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 14 Jan 2016 22:12:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/01/14/usually-js%E6%AD%A3%E5%88%99/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/01/14/usually-js%E6%AD%A3%E5%88%99/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JS正则表达式总结</title>
        <description>&lt;h2 id=&quot;js&quot;&gt;JS正则表达式总结&lt;/h2&gt;
&lt;p&gt;正则表达式通常用于两种任务：1.验证，2.搜索/替换。&lt;/p&gt;

&lt;p&gt;*字符类匹配&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[...]	方括号内的任意字符
[^...]	不在方括号内的任意字符
.	除了换行符和其他Unicode行终止符之外的任意字符
\w	任何ASCII字符组成的单词，等价于[a-zA-Z0-9]
\W	任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]
\s	任何Unicode空白符
\S	任何非Unicode空白符的字符
\d	任何ASCII数字，介于[0-9]
\D	除了ASCII数字之外的任何字符，等价于[^0-9]
\b	退格直接量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*重复字符匹配&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{n,m}	匹配前一项至少n次，但不能超过m次
{n,}	匹配前一项n次或更多次
{n}	匹配前一项n次
？	匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0，1}
+	匹配前一项1次或多次，等价于{1，}
*	匹配前一项0次或多次，等价于{0，}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*正则表达式修饰符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i        执行不区分大小写的匹配
g        执行一个全局匹配，即找到所有匹配而非一次匹配
m        多行匹配模式，^匹配一行的开头和字符串开头，$匹配行的结束和字符串的结尾
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*RegExp的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test()：检索字符串中的指定值。返回值是布尔值。
exec()：返回一个数组，数组中的第一个条目是第一个匹配，其他的是反向引用
compile()：既可以改变检索模式，也可以添加或删除第二个参数。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*String 对象中的正则表达式方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;match(pattern)	返回 pattern 中的子串或 null
replace(pattern, replacement)	用 replacement 替换 pattern
search(pattern)	返回字符串中 pattern 开始位置
split(pattern)	返回字符串按指定 pattern 拆分的数组
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*特殊字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var re = /(\w+)\s(\w+)/;
var str = &#39;John Smith&#39;;
str.replace(re, &#39;$2, $1&#39;); // &quot;Smith, John&quot;
RegExp.$1; // &quot;John&quot;
RegExp.$2; // &quot;Smith&quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 12 Jan 2016 22:12:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/01/12/zhengze/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/01/12/zhengze/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>各种top、left、height</title>
        <description>&lt;h2 id=&quot;topleftheight&quot;&gt;各种top、left、height&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;网页可见区域宽： document.body.clientWidth;&lt;br /&gt;
网页可见区域高： document.body.clientHeight;&lt;br /&gt;
网页可见区域宽： document.body.offsetWidth   (包括边线的宽);&lt;br /&gt;
网页可见区域高： document.body.offsetHeight  (包括边线的宽);&lt;br /&gt;
网页正文全文宽： document.body.scrollWidth;&lt;br /&gt;
网页正文全文高： document.body.scrollHeight;&lt;br /&gt;
网页被卷去的高： document.body.scrollTop;&lt;br /&gt;
网页被卷去的左： document.body.scrollLeft;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;假设 obj 为某个 HTML 控件。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;obj.offsetTop 指 obj 距离上方或上层控件的位置，整型，单位像素。
obj.offsetLeft 指 obj 距离左方或上层控件的位置，整型，单位像素。
obj.offsetWidth 指 obj 控件自身的宽度，整型，单位像素。
obj.offsetHeight 指 obj 控件自身的高度，整型，单位像素。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;offsetTop 与 style.top 的区别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、offsetTop 返回的是数字，而 style.top 返回的是字符串，除了数字外还带有单位：px。
2、offsetTop 只读，而 style.top 可读写。
3、如果没有给 HTML 元素指定过 top 样式，则 style.top 返回的是空字符串。
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;offsetWidth 与 style.width 的区别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;如对象的宽度设定值为百分比宽度,则无论页面变大还是变小,style.width都返回此百分比,而offsetWidth则返回在不同页面中对象的宽度值而不是百分比值
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;clientHeight、offsetHeight和scrollHeight 的区别&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;clientHeight 就是透过浏览器看内容的这个区域高度。
NS（Netscape）、 FF （FireFox）认为 offsetHeight 和 scrollHeight 都是网页内容高度，只不过当网页内容高度小于等于 clientHeight 时，scrollHeight 的值是 clientHeight，而 offsetHeight 可以小于 clientHeight。
IE、Opera 认为 offsetHeight 是可视区域 clientHeight 滚动条加边框。scrollHeight 则是网页内容实际高度。
&lt;/code&gt;&lt;/pre&gt;

</description>
        <pubDate>Mon, 21 Dec 2015 06:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/12/21/top-left-height/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/12/21/top-left-height/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>web跨域解决方案</title>
        <description>&lt;h2 id=&quot;web&quot;&gt;web跨域解决方案&lt;/h2&gt;
&lt;p&gt;我们都知道HTML的同源策略不允许JavaScript进行跨域操作，但随着Web App的功能越来越强，各种跨域的需求催生了无数的跨域手法。&lt;br /&gt;
   跨域办法大致可以分为两类:&lt;br /&gt;
    &lt;em&gt;1、一类是hack,比如通过title, navigation等对象传递信息，JSONP可以说是一个最优秀的Hack。&lt;/em&gt;&lt;br /&gt;
    &lt;em&gt;2、另一类是HTML5支持，一个是Access-Control-Allow-Origin响应头，一个是window.postMessage&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&quot;documentdomain&quot;&gt;设置 document.domain&lt;/h4&gt;
&lt;p&gt;原理：相同主域名不同子域名下的页面，可以设置document.domain让它们同域&lt;br /&gt;
   限制：同域document提供的是页面间的互操作，需要载入iframe页面&lt;/p&gt;

&lt;h4 id=&quot;jsonp&quot;&gt;JSONP&lt;/h4&gt;
&lt;p&gt;原理：script是可以跨域的，而且在跨域脚本中可以直接回调当前脚本的函数。&lt;br /&gt;
   限制：需要创建一个DOM对象并且添加到DOM树，只能用于GET方法&lt;/p&gt;

&lt;p&gt;&lt;em&gt;跨域URL返回的脚本不仅包含数据，还包含一个回调：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  // URL: http://b.a.com/foo
    var data = {
        foo: &#39;bar&#39;,
        bar: &#39;foo&#39;
    };
    callback(data);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;然后在我们在主站http://a.com中，可以这样来跨域获取http://b.a.com的数据：&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    // URL: http://a.com/foo
    var callback = function(data){
        // 处理跨域请求得到的数据
    };
    var script = $(&#39;&amp;lt;script&amp;gt;&#39;, {src: &#39;http://b.a.com/bar&#39;});
    $(&#39;body&#39;).append(script);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;其实jQuery已经封装了JSONP的使用，我们可以这样来&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $.getJSON( &quot;http://b.a.com/bar?callback=callback&quot;, function( data ){
        // 处理跨域请求得到的数据
    });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;$.getJSON与$.get的区别是前者会把responseText转换为JSON，而且当URL具有callback参数时， jQuery将会把它解释为一个JSONP请求，创建一个script标签来完成该请求。&lt;/p&gt;

&lt;h4 id=&quot;windowpostmessage&quot;&gt;window.postMessage&lt;/h4&gt;
&lt;p&gt;原理：HTML5允许窗口之间发送消息&lt;br /&gt;
限制：浏览器需要支持HTML5，获取窗口句柄后才能相互通信&lt;/p&gt;

&lt;h4 id=&quot;cors&quot;&gt;跨域资源共享（CORS）&lt;/h4&gt;
&lt;p&gt;原理：服务器设置Access-Control-Allow-OriginHTTP响应头之后，浏览器将会允许跨域请求&lt;br /&gt;
限制：浏览器需要支持HTML5，可以支持POST，PUT等方法&lt;/p&gt;

&lt;h4 id=&quot;navigation-&quot;&gt;navigation 对象&lt;/h4&gt;
&lt;p&gt;原理：iframe之间是共享navigator对象的，用它来传递信息&lt;br /&gt;
要求：IE6/7&lt;/p&gt;

&lt;h4 id=&quot;src&quot;&gt;有src的标签&lt;/h4&gt;
&lt;p&gt;原理：所有具有src属性的HTML标签都是可以跨域的，包括img, script&lt;br /&gt;
   限制：需要创建一个DOM对象，只能用于GET方法&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;http://harttle.com/2015/10/10/cross-origin.html&quot;&gt;参考文章&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Wed, 16 Dec 2015 04:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/12/16/web-cross/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/12/16/web-cross/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>易混淆的方法</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;易混淆的方法&lt;/h2&gt;

&lt;p&gt;parent()：查找&lt;em style=&quot;color:red;&quot;&gt;直接的&lt;/em&gt;父节点&lt;br /&gt;
  parents()：查找&lt;em style=&quot;color:red;&quot;&gt;所有的&lt;/em&gt;祖先元素&lt;br /&gt;
  sibling()：查找兄弟节点，不分前后&lt;br /&gt;
  children()：查找所有子元素，只会找到&lt;em style=&quot;color:red;&quot;&gt;直接的&lt;/em&gt;孩子节点，不会返回所有子孙&lt;br /&gt;
  find()：会在div元素内 寻找 class为classname的元素。(&lt;em style=&quot;color:red;&quot;&gt;子元素&lt;/em&gt;找)&lt;br /&gt;
  filter()：则是筛选div的class为classname的元素。(&lt;em style=&quot;color:red;&quot;&gt;平级&lt;/em&gt;找)&lt;/p&gt;

&lt;p&gt;get()：接受一个索引值参数并返回对应的DOM节点&lt;br /&gt;
  index()：接受一个DOM节点然后返回其索引值，index(this)返回当前值的索引值&lt;br /&gt;
  eq(index)：index为正整数时以0为基数，index为负整数时从集合中的最后一个元素开始倒数（从1开始倒数）&lt;/p&gt;
</description>
        <pubDate>Wed, 02 Dec 2015 02:05:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/12/02/parents-children/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/12/02/parents-children/</guid>
        
        <category>Jquery</category>
        
        
      </item>
    
      <item>
        <title>tab切换</title>
        <description>&lt;h2 id=&quot;tab&quot;&gt;tab切换&lt;/h2&gt;

&lt;p&gt;HTML部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;ul class=&quot;tabs&quot; id=&quot;tab&quot;&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;javascript:void(0)&quot; class=&quot;current&quot;&amp;gt;tab切换一&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;javascript:void(0)&quot; &amp;gt;tab切换二&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
    &amp;lt;li&amp;gt;&amp;lt;a href=&quot;javascript:void(0)&quot;&amp;gt;tab切换三&amp;lt;/a&amp;gt;&amp;lt;/li&amp;gt;
&amp;lt;/ul&amp;gt;

&amp;lt;div class=&quot;container&quot; id=&quot;contain&quot;&amp;gt;
    &amp;lt;div class=&quot;con&quot;&amp;gt;显示内容一&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;con&quot;&amp;gt;显示内容二&amp;lt;/div&amp;gt;
    &amp;lt;div class=&quot;con&quot;&amp;gt;显示内容三&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Jquery部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$(function(){
    tabs($(&quot;#tab a&quot;), $(&#39;#contain .con&#39;));  
});

var tabs = function(tab, con){
    tab.click(function(){
        var dIndex = tab.index(this);
        tab.removeClass(&#39;current&#39;);
        $(this).addClass(&#39;current&#39;);
        con.hide();
        con.eq(dIndex).show();
    });    
}
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 20 Nov 2015 17:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/11/20/tab-change/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/11/20/tab-change/</guid>
        
        <category>Jquery</category>
        
        
      </item>
    
      <item>
        <title>文字向上滚动</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;文字向上滚动&lt;/h2&gt;

&lt;p&gt;HTML部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;div class=&quot;content_three&quot; id=&quot;content_three&quot;&amp;gt;
	&amp;lt;div class=&quot;list_all&quot; id=&quot;list_all&quot;&amp;gt;&amp;lt;/div&amp;gt;
	&amp;lt;div class=&quot;list_all&quot; id=&quot;list_copy&quot;&amp;gt;&amp;lt;/div&amp;gt;
&amp;lt;/div&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;js部分&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var speed = 40 ;
var content_three = document.getElementById(&quot;content_three&quot;);  
var list_copy = document.getElementById(&quot;list_copy&quot;);  
var list_all = document.getElementById(&quot;list_all&quot;);  
list_copy.innerHTML = list_all.innerHTML + list_all.innerHTML;

function Marquee() {  
    if (list_copy.offsetTop - content_three.scrollTop &amp;lt;= 0)  
        content_three.scrollTop -= list_all.offsetHeight ; 
    else {  
        content_three.scrollTop++ ; 
    }  
}  
var MyMar = setInterval(Marquee, speed);  
content_three.onmouseover = function() { clearInterval(MyMar)} 
content_three.onmouseout = function() { MyMar = setInterval(Marquee, speed)} 
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 13 Nov 2015 04:07:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/11/13/scroll-up/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/11/13/scroll-up/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>移动web经验总结</title>
        <description>&lt;h2 id=&quot;web&quot;&gt;移动web经验总结&lt;/h2&gt;

&lt;p&gt;一、头部引用&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&quot;viewport&quot; content=&quot;width=device-width; initial-scale=1.0; maximum-scale=1.0; user-scalable=0;&quot; /&amp;gt;&amp;lt;!-- 禁止缩放 --&amp;gt;

&amp;lt;meta http-equiv=&quot;Cache-Control&quot; content=&quot;no-cache&quot; /&amp;gt;&amp;lt;!-- 清浏览器缓存 --&amp;gt;

&amp;lt;meta content=&quot;telephone=no&quot; name=&quot;format-detection&quot;&amp;gt;&amp;lt;!-- 告诉设备忽略将页面中的数字识别为电话号码 --&amp;gt;

&amp;lt;meta name=&quot;apple-mobile-web-app-capable&quot; content=&quot;yes&quot; /&amp;gt;&amp;lt;!-- 删除默认的苹果工具栏和菜单栏。 --&amp;gt;

&amp;lt;meta name=&quot;apple-mobile-web-app-status-bar-style&quot; content=&quot;black&quot; /&amp;gt;&amp;lt;!-- 当启用webapp功能时，控制手机顶部导航栏的颜色，根据实际页面的主题色进行设置 --&amp;gt;

&amp;lt;meta name=&quot;apple-mobile-web-app-capable&quot; contenat=&quot;yes&quot; /&amp;gt;&amp;lt;!-- 网站开启对web app程序的支持 --&amp;gt;

&amp;lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge,chrome=1&quot;/&amp;gt; &amp;lt;!-- 优先使用 IE 最新版本和 Chrome --&amp;gt;

&amp;lt;meta content=&quot;email=no&quot; name=&quot;format-detection&quot; /&amp;gt;&amp;lt;!-- 禁止Android自动识别页面中的邮件地址 --&amp;gt;

&amp;lt;meta content=&quot;description&quot; content=&quot;内容不超过150字&quot; /&amp;gt; &amp;lt;!-- 页面描述--&amp;gt;

&amp;lt;meta name=&quot;keywords&quot; content=&quot;&quot;/&amp;gt;     &amp;lt;!-- 页面关键词 --&amp;gt;

&amp;lt;meta name=&quot;msapplication-tap-highlight&quot; content=&quot;no&quot;&amp;gt;   &amp;lt;!-- windows phone 点击无高光 --&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;二、整体布局&lt;/p&gt;

&lt;p&gt;慎用flex布局，本人亲测，flex布局在安卓机上不是很管用，详见请点击&lt;a href=&quot;http://www.ayqy.net/blog/flexbox%E5%B8%83%E5%B1%80%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7/&quot;&gt;说明&lt;/a&gt;；&lt;/p&gt;

&lt;p&gt;三、使用html5&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;1、简洁的 DOCTYPE HTML5 只需一个简洁的文档类型：&amp;lt;!DOCTYPE html&amp;gt;。它有意不使用版本，因此文档将会适用所有版本的HTML。&lt;br /&gt;
    2、简单易记的语言标签 你并不需要在 &amp;lt;html&amp;gt; 中使用 xmlns 或 xml:lang 标记。 &amp;lt;html lang=”en”&amp;gt; 将对 HTML5 有效。&lt;br /&gt;
    3、简单易记的编码类型 你现在可以在 meta 标签中使用 “charset”：&amp;lt;meta charset=”utf-8″ /&amp;gt;&lt;br /&gt;
    4、不需要闭合标签 在 HTML5 中，空标签（如：br、img 和 input ）并不需要闭合标签。&lt;br /&gt;
    5、新增标签 新增的语义化标签&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;header:用于表示头部区域;
hgroup:我们可以使用 hgroup 元素包裹网站标题（h1)和网站副标题（h2）;
nav:通常用于以下场合：网站导航条、侧边栏导航条、页内导航、前页后页翻页等。但是，普遍认为的是，一个页面上最好只用一个 nav 标签，用它来标记最重要的导航条（一般就是网站的导航条）。这样，可以让搜索引擎等快速定位，避免误导;
section:通常对网站或页面上的内容，进行分开[article 元素与 section 元素区别详解](http://www.qianxingzhem.com/post-915.html)；
article:来表示文档、页面或者独立的、完整的、可以独自被外部引用的内容;
aside:表示属于这个 article 的相关描述信息。此外,aside 也用于边栏功能;
time:标记文字的发布时间，可以让机器、搜索引擎等理解这篇文章是什么时间发表的;
figure:规定独立的流内容（图像、图表、照片、代码等等）;
figcaption:元素应该被置于 &quot;figure&quot; 元素的第一个或最后一个子元素的位置。
mark, audio, video, source, track, bdi, canvas, command, datalist, summary, embed, keygen, meter, output, progress, rp, rt, ruby。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;6、新增属性 在 HTML5 中，增加了很多form表单属性，当然还有其他属性。 required, from, pattern, placeholder, email, range[min, max, step], url, date, time, datetime, datetime-local, month, week, tel, number, search, –, contentcontenteditableable, contextmenu, data-yourvalue, draggable, item, itemprop,spellcheck, subject。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;四、字的单位&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;使用rem(是通过根元素进行适配的，网页中的根元素指的是html我们通过设置html的字体大小就可以控制rem的大小);&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Fri, 06 Nov 2015 04:07:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/11/06/yidong-web/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/11/06/yidong-web/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>JavaScript闭包理解</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;闭包这个问题一直以来比较生涩，今天一个同事给了他的理解：闭包就是防止全局变量污染。&lt;br /&gt;
  然后我专门上网查了下，总结了以下几点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;闭包定义&lt;/h2&gt;
&lt;p&gt;闭包通俗点说就是能够读取其他函数内部变量的函数（是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;闭包的好处&lt;/h2&gt;
&lt;p&gt;1.希望一个变量长期驻扎在内存中&lt;br /&gt;
  2.避免全局变量的污染&lt;br /&gt;
  3.私有成员的存在&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;理解最深的就是避免全局变量的污染，通俗点说就是相同的变量互不干扰。比如我们定义了一个全局变量，在同一个函数里面又定义了多个和全局相同的变量，通常这种情况会导致全局变量会出错，但是引用闭包后就不会出现这种情况。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 25 Oct 2015 04:30:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/10/25/JS-bibao/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/10/25/JS-bibao/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
  </channel>
</rss>
