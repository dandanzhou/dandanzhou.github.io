<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daisydan</title>
    <description>前端开发工程师一枚！</description>
    <link>https://dandanzhou.github.io/</link>
    <atom:link href="https://dandanzhou.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Wed, 09 Nov 2016 17:03:28 +0800</pubDate>
    <lastBuildDate>Wed, 09 Nov 2016 17:03:28 +0800</lastBuildDate>
    <generator>Jekyll v3.1.6</generator>
    
      <item>
        <title>总结及计划</title>
        <description>&lt;p&gt;打开博客，突然发现自己已经好久没有写博客了，再忙也得抽时间写写博客。&lt;/p&gt;

&lt;p&gt;来到新公司将近半年了，感觉收获的不少也不是很多，大部分还是自己很少总结。今天刚好有时间，总结一下顺便计划下年底前要完成的任务。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;总结&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1、了解到了typeSript；

    *TypeScript增加了可选类型、类和模块
    *TypeSript可编译成可读的、标准的JavaScript（ts编译成js）
    *TypeScript扩展了JavaScript语法，已有的JavaScript代码可直接与现有的TypeScript一起运行
    *Arrow函数（类似于c#的Lambda函数）

2、熟悉了服务器上一些基本的linux命令；

3、前端一些细小的知识点得到了理解。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;11月底要完成的事&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1、W3C/HTTP规范、HTTP协议、Web安全；
2、继续把phython看完并做出一个demo；
3、熟练编写常用的数据结构和算法；
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Wed, 09 Nov 2016 00:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/11/09/plan/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/11/09/plan/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>webpack打包工具</title>
        <description>&lt;p&gt;最近在webpack上折腾了几天，终于有了眉目，差点就要放弃了，折腾的过程中最大的收获就是：掌握了学习新东西的方法～～&lt;/p&gt;

&lt;h2 id=&quot;webpack&quot;&gt;折腾的第一点:下载webpack&lt;/h2&gt;
&lt;p&gt;最开始全局下载webpack,也就是npm install -g webpack比较顺利，但是后来在根目录下npm install webpack，一直报错如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/webpack1.jpg&quot; alt=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/webpack1.jpg&quot; /&gt;&lt;/p&gt;

&lt;p&gt;最关键的是我在别人电脑上一安装就成了－－
在网上查了各种解决方案，但最终都木有解决问题，后来突然想到了之前装gulp的时候，每次装到gulp-sass时会出现问题（后来直接把以前好的gulp－sass复制了过来）；
于是我决定把根目录下的node_modules全删了，重新安装，当安装到gulp－sass,同样出现了问题，在网上找到了一个解决方案，直接执行：npm install rebulid,终于成功安装了gulp;
接着在根目录下安装webpack时，成功了！！！&lt;/p&gt;

&lt;h2 id=&quot;webpack-1&quot;&gt;折腾的第二点：webpack的配置文件及运行&lt;/h2&gt;

&lt;p&gt;为了实际演示，我在目前的项目中，用webpack打包了ts文件如下：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/webpack2.png&quot; alt=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/webpack2.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;在做好配置后，运行webpack,也出现了问题，原因是在根目录下没有下载ts-loader,后来才知道，每一种模块对应的loader都应该先下载（只要配置中有就要下载）&lt;/p&gt;

&lt;p&gt;目前，只是webpack有了一个大概的了解和大概的实际操作，还需我继续去探索～～&lt;/p&gt;

</description>
        <pubDate>Thu, 04 Aug 2016 00:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/08/04/webpack/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/08/04/webpack/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>随笔</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;想到啥就写啥了&lt;/h2&gt;

&lt;p&gt;7月的尾巴渐渐逼近，不得不感叹时间之飞快，这个月貌似发生的事儿还是挺多的，不过总算是挺过来了。。。&lt;/p&gt;

&lt;p&gt;新公司也没有之前那么忙了，该多花点功夫在新技术了，上个星期借的书，得快点看完了，感觉自己有时候开始有点懒，还是得慢慢改掉这个坏毛病。&lt;/p&gt;

&lt;p&gt;偶然看到的几句话还是挺激励我的：放下懒惰 ––奋斗改变命运，绝招就是把一件平凡的小事做到炉火纯青，就是绝活。提醒自己，记住自己的提醒，上进的你，快乐的你，健康的你，善良的你，一定会有一个灿烂的人生。&lt;/p&gt;

&lt;p&gt;减肥和学习是女人的终生事业啊，哈哈哈哈，已经减了两个星期，初见成效，但还没达到想要的效果，还得继续努力；学习吧，定是不能落下的，按照自己的脚步，慢慢来，总会有属于我的小幸运～～&lt;/p&gt;

</description>
        <pubDate>Sat, 23 Jul 2016 00:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/07/23/others/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/07/23/others/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>web静态资源缓存自动更新</title>
        <description>&lt;p&gt;核心：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;在每次发布之前，利用Gulp对所有的静态资源进行预处理，重命名为原文件名 + 文件MD5值 + 文件后缀名的形式。比如register.js重命名为register-87f3f22ee7.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;步骤：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1、先用npm下载gulp-clean  gulp-rev  gulp-rev-collector这几个依赖，其次配置好gulpfile.js里面的内容（已配置好），有兴趣可去项目根目录里面查看；
2、如果第一步已经完成，如果你只是修改了www端得css或者ts，依次执行gulp www-clean( 取决于你gulpfile.js里面的配置) 、gulp ，然后在你配置的相关文件里面就会生成对应的rev-manifest.json（路径：public/assets/rev/css/和public/assets/rev/js/），如下图所示
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/cache1.png&quot; alt=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/cache1.png&quot; /&gt;
&lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/cache2.png&quot; alt=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/cache2.png&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3、到这里对应css名称就会发生对应的变化
但是js没有，为什么呢？？？？？？ 因为我们项目里面用的是require模块加载，在每个html里面都是require对应的js，而不是普通的&amp;lt;script src=&quot;&quot;&amp;gt;&amp;lt;/script&amp;gt;。
在网上找了一些相关资料，有两种还凑合：
(1)在require.congfig配置里面加上 urlArgs: &quot;bust=&quot; +  (new Date()).getTime()，但这只适合开发环境
(2)在每次发布的时候需要根据rev-manifest在require.congfig对模块进行mapping，将配置文件以内联JS的形式写入到模版页面里面，类似于：
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/cache3.png&quot; alt=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/cache3.png&quot; /&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;看起来有点麻烦哈，因为每次修改完js或者pull代码获得更新的js，rev-manifest.json里面对应的js名称后的一串字符会自动变化，但是require.congfig里面需要我们手动去改变，这需要我们细心啊啊啊啊啊！！！！
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Sat, 11 Jun 2016 00:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/06/11/web-clear-cache/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/06/11/web-clear-cache/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>支付拦截解决方案</title>
        <description>&lt;p&gt;额，先说点题外话哈。真实惭愧啊，距离上次写博客差不多有两个月的时间了。该写了，直接进入正题吧，哈哈哈哈…&lt;/p&gt;

&lt;p&gt;如果你是直接点击充值跳到另外一个页面，不用向第三方传一些数据，以下就不用看了。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;支付拦截解决方案&lt;/h2&gt;
&lt;p&gt;上个星期和后端做支付对接的时候，遇到一个小问题：点击充值按钮进行充值跳到第三方充值页的时候，充值页被拦截了！！！！！&lt;/p&gt;

&lt;p&gt;背景：点击充值的时候后台要我先传金额获取一些数据然后再掉充值接口跳到支付页&lt;/p&gt;

&lt;p&gt;于是出现如下图所示：
 &lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/fail.png&quot; alt=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/fail.png&quot; /&gt;&lt;/p&gt;

&lt;p&gt;后来在网上查找了原因，原来是这样滴：
    用户自己发起的浏览器不会阻止，如果触发动作是自动执行的则浏览器会阻止打开。（进入ajax是自动的但是ajax执行完）会认为你是弹广告xxxxxxx！想不被阻止就想办法让动作换成用户自己发起的。&lt;/p&gt;

&lt;p&gt;所以有了以下解决方案：
    由于之前跳到支付页用的xx.submit()，是在ajax内自动执行完的，并不是用户自己发起的；所以我们需要一个过渡，就是把这个动作赋予用户自己完成。
    我的想法是点击充值时让先弹出一个窗口确定输入的金额，然后让用户点击确定调用xx.sumbit();经过试验真的成功了。&lt;/p&gt;

&lt;p&gt;成功后的如下图：
  &lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/way.png&quot; alt=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/way.png&quot; /&gt;
  &lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/success.png&quot; alt=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/success.png&quot; /&gt;&lt;/p&gt;

</description>
        <pubDate>Sun, 05 Jun 2016 00:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/06/05/ajax-interception/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/06/05/ajax-interception/</guid>
        
        <category>Others</category>
        
        
      </item>
    
      <item>
        <title>神奇的BFC</title>
        <description>&lt;h2 id=&quot;bfc&quot;&gt;神奇的BFC&lt;/h2&gt;
&lt;p&gt;BFC，当别人向我提到这个词的时候，我脑袋里是一片空白，工作大半年了，连这个都不知道，甚是惭愧啊~~
于是在网上查找相关资料整理如下：&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;BFC定义及规则&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;BFC(block formatting context),汉译为块级格式化上下文 
* 内部box会在垂直方向一个接一个放置；
* Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠；
* 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此；
* BFC的区域不会与float box重叠；
* BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此；
* 计算BFC的高度时，浮动元素也参与计算。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;哪些元素会生成BFC&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;* 根元素；
* float属性不为none；
* position为absolute或fixed；
* display为inline-block, table-cell, table-caption, flex, inline-flex；
* overflow不为visible。
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;BFC的作用及原理&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;* 自适应两栏布局（BFC的区域不会与float box重叠，我们可以通过通过触发main生成BFC， 来实现自适应两栏布局）
* 清除内部浮动（计算BFC的高度时，浮动元素也参与计算）
* 防止垂直margin重叠（Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠。因此生成一个BFC。那么两块便不属于同一个BFC，就不会发生margin重叠了）
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Fri, 11 Mar 2016 01:04:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/03/11/BFC/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/03/11/BFC/</guid>
        
        <category>CSS</category>
        
        
      </item>
    
      <item>
        <title>Promise初探</title>
        <description>&lt;h2 id=&quot;promise&quot;&gt;Promise初探&lt;/h2&gt;
&lt;p&gt;Promise是抽象异步处理对象以及对其进行各种操作的组件。&lt;/p&gt;

&lt;p&gt;创建promise对象的流程如下所示。		
 1、new Promise(fn) 返回一个promise对象&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var promise = new Promise(function(resolve, reject) {		
            // 异步处理		
            // 处理结束后、调用resolve 或 reject		
    });		
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;2、在fn 中指定异步等处理&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;处理结果正常的话，调用resolve(处理结果值)		
处理结果错误的话，调用reject(Error对象)		
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Promise.reject(error)是和 Promise.resolve(value) 类似的静态方法，是 new Promise() 方法的快捷方式。		
 比如 Promise.resolve(42); 可以认为是以下代码的语法糖。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Promise(function(resolve){		
  resolve(42);		
});		
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比如 Promise.reject(new Error(“出错了”)) 就是下面代码的语法糖形式。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;new Promise(function(resolve,reject){		
   reject(new Error(&quot;出错了&quot;));		
});		
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;promise可以写成方法链的形式&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;function taskA() {		
    console.log(&quot;Task A&quot;);		
}		
function taskB() {		
    console.log(&quot;Task B&quot;);		
}		
function onRejected(error) {		
     console.log(&quot;Catch Error: A or B&quot;, error);		
}		
function finalTask() {		
     console.log(&quot;Final Task&quot;);		
}		
        
var promise = Promise.resolve();		
promise		
   .then(taskA)		
   .then(taskB)		
   .catch(onRejected)		
   .then(finalTask);		
                
运行结果：Task A		
Task B		
Final Task	
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 10 Mar 2016 05:12:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/03/10/promise/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/03/10/promise/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>url从浏览器输入到页面呈现</title>
        <description>&lt;h2 id=&quot;url&quot;&gt;url从浏览器输入到页面呈现&lt;/h2&gt;
&lt;p&gt;前段时间有人问我“从输入URL到页面加载完成的过程中都发生了什么”，当时脑袋里的碎片零零散散，就是不知道怎样完整的回答，今天刚好有时间把它给好好整理整理。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;主要的流程&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;DNS解析--&amp;gt;建立连接，发送数据包 --&amp;gt;服务器响应请求，返回给浏览器--&amp;gt;浏览器渲染程序页面。
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;DNS解析
首先在浏览器输入了一个URL地址，但URL中服务器地址是一个域名而不是一个指定的IP地址，路由器并不知道你想要查找的地址，那么DNS域名解析系统会将该域名解析成ip，而IP地址是唯一的， 每一个ip地址对应网络上的一台计算机。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;建立网络连接，发送数据包
由于以上的努力，已经能够根据ip和端口号与网络上对应的服务器建立连接，浏览器这边会向服务器发送一个数据包，里面包含了大量的信息，但这个数据包有一定的格式。就像我给你邮个快递，也得遵循邮递公司的一些规则吧！我得写上我的身份信息、寄的物品、标明邮递地址….道理是一样的，到了网络中这些规则就是“Http协议(网络协议)”
http协议是客户端和服务器端两者通信共同遵循的一些规则。主要内容是定义了客户端如何向服务器请求资源，服务器如何响应客户端请求。&lt;/p&gt;

    &lt;p&gt;请求中的POST与 GET方法有什么区别？
  1.根据HTTP规范，GET用于信息获取，而且应该是安全的,这里的安全是指非修改的信息，就像在数据库执行查询一样，不会修改数据，也不会增加删减数据，不会影响资源的状态，而post可能会改变数据的原始状态。
  2.GET提交的数据最多只有1024字节，理论上POST是没有限制的。
  3.从请求的URL中可以找到一个区别：GET请求的数据会附在URL之后，在浏览器URL栏就能看的。似乎POST比GET更可靠一些，因为它请求把提交的数据放在包体中，地址栏上不可见。（也有的解释说两者都没有长度限制，根本的区别就是一个是获取数据，一个修改数据！）&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;服务器响应请求，返回给浏览器
服务器会分解你的数据包，例如你查找的是一个文档，那么服务器可能会返回一个doc文档或者zip压缩资源给你；如果你访问的是一个链接页面，那么服务器相应的返回一个包含HTML/CSS标记文档，这些请求和响应都有一个通用的写法，这些规则也就是前面提到的”http协议”。
客户端向服务器请求资源时，除了告诉服务器要请求的资源，同时还会附带一些其他的信息，这部分信息放在”header”部分（服务器响应请求也一样！），主要有请求头(略)和响应头&lt;/p&gt;

    &lt;p&gt;200	OK	一切正常，对GET和POST请求的应答文档跟在后面。
  201	Created	服务器已经创建了文档，Location头给出了它的URL。
  202	Accepted	已经接受请求，但处理尚未完成。&lt;/p&gt;

    &lt;p&gt;300	Multiple Choices	客户请求的文档可以在多个位置找到，这些位置已经在返回的文档内列出。如果服务器要提出优先选择，则应该在Location应答头指明。
  301	Moved Permanently	永久重定向。
  302	Found	临时重定向
  304	Not Modified	客户端有缓冲的文档并发出了一个条件性的请求。服务器告 诉客户，原来缓冲的文档还可以继续使用。&lt;/p&gt;

    &lt;p&gt;400	Bad Request	请求出现语法错误。
  403	Forbidden	资源不可用。服务器理解客户的请求，但拒绝处理它。通常由于服务器上文件或目录的权限设置导致。
  404	Not Found	无法找到指定位置的资源。这也是一个常用的应答。
  405	Method Not Allowed	请求方法（GET、POST、HEAD、DELETE、PUT、TRACE等）对指定的资源不适用。（HTTP 1.1新）&lt;/p&gt;

    &lt;p&gt;500	Internal Server Error	服务器遇到了意料不到的情况，不能完成客户的请求。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;客户端渲染 
 渲染引擎得到html字符串作为输入，然后对html进行转换，转化成能够被DOM处理的形式，接着转换成一个dom树，在解析html的过程，解析到link、script、img等一些请求标签时，会发送请求把对应的内容获取到。这时又会同步进行css的解析，构建出css样式规则应用到dom树上，然后进行一定的布局处理，比如标记节点块在浏览器中的坐标等形成最终的渲染树，最后根据这棵渲染树在浏览器窗口中进行绘制。
View&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Wed, 09 Mar 2016 04:00:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/03/09/url/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/03/09/url/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>Js常用正则</title>
        <description>&lt;h2 id=&quot;js&quot;&gt;Js常用正则&lt;/h2&gt;
&lt;p&gt;前端开发中总避免不了使用一些正则表达式来处理一些问题，下面就列常用的几例&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;字符串去重&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;var str = &quot;adsfjjbkk&quot;;  
// \1匹配第一个子串  
// 只去除连续重复  
console.log(str.replace(/(.)(\1)+/g,function($1,$2,$3){  
    return $2;  
}));// adsfjbk
&lt;/code&gt;&lt;/pre&gt;

&lt;blockquote&gt;
  &lt;p&gt;js获取URL中的参数&lt;/p&gt;
&lt;/blockquote&gt;

&lt;pre&gt;&lt;code&gt;function GetQueryString(name) {
    var reg = new RegExp(&quot;(^|&amp;amp;)&quot; + name + &quot;=([^&amp;amp;]*)(&amp;amp;|$)&quot;, &quot;i&quot;);
    var r = window.location.search.substr(1).match(reg); //获取url中&quot;?&quot;符后的字符串并正则匹配
    var context = &quot;&quot;;
    if (r != null)
    context = r[2];
    reg = null;
    r = null;
    return context == null || context == &quot;&quot; || context == &quot;undefined&quot; ? &quot;&quot; : context;
}
alert(GetQueryString(&quot;q&quot;));
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Thu, 14 Jan 2016 22:12:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/01/14/usually-js%E6%AD%A3%E5%88%99/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/01/14/usually-js%E6%AD%A3%E5%88%99/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JS正则表达式总结</title>
        <description>&lt;h2 id=&quot;js&quot;&gt;JS正则表达式总结&lt;/h2&gt;
&lt;p&gt;正则表达式通常用于两种任务：1.验证，2.搜索/替换。&lt;/p&gt;

&lt;p&gt;*字符类匹配&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[...]	方括号内的任意字符
[^...]	不在方括号内的任意字符
.	除了换行符和其他Unicode行终止符之外的任意字符
\w	任何ASCII字符组成的单词，等价于[a-zA-Z0-9]
\W	任何不是ASCII字符组成的单词，等价于[^a-zA-Z0-9]
\s	任何Unicode空白符
\S	任何非Unicode空白符的字符
\d	任何ASCII数字，介于[0-9]
\D	除了ASCII数字之外的任何字符，等价于[^0-9]
\b	退格直接量
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*重复字符匹配&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{n,m}	匹配前一项至少n次，但不能超过m次
{n,}	匹配前一项n次或更多次
{n}	匹配前一项n次
？	匹配前一项0次或者1次，也就是说前一项是可选的，等价于{0，1}
+	匹配前一项1次或多次，等价于{1，}
*	匹配前一项0次或多次，等价于{0，}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*正则表达式修饰符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;i        执行不区分大小写的匹配
g        执行一个全局匹配，即找到所有匹配而非一次匹配
m        多行匹配模式，^匹配一行的开头和字符串开头，$匹配行的结束和字符串的结尾
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*RegExp的方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;test()：检索字符串中的指定值。返回值是布尔值。
exec()：返回一个数组，数组中的第一个条目是第一个匹配，其他的是反向引用
compile()：既可以改变检索模式，也可以添加或删除第二个参数。 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*String 对象中的正则表达式方法&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;match(pattern)	返回 pattern 中的子串或 null
replace(pattern, replacement)	用 replacement 替换 pattern
search(pattern)	返回字符串中 pattern 开始位置
split(pattern)	返回字符串按指定 pattern 拆分的数组
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;*特殊字符&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;var re = /(\w+)\s(\w+)/;
var str = &#39;John Smith&#39;;
str.replace(re, &#39;$2, $1&#39;); // &quot;Smith, John&quot;
RegExp.$1; // &quot;John&quot;
RegExp.$2; // &quot;Smith&quot;
&lt;/code&gt;&lt;/pre&gt;
</description>
        <pubDate>Tue, 12 Jan 2016 22:12:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2016/01/12/zhengze/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2016/01/12/zhengze/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
  </channel>
</rss>
