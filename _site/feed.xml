<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Daisydan</title>
    <description>前端开发工程师一枚！</description>
    <link>https://dandanzhou.github.io/</link>
    <atom:link href="https://dandanzhou.github.io/feed.xml" rel="self" type="application/rss+xml" />
    <pubDate>Fri, 30 Oct 2015 20:03:34 +0800</pubDate>
    <lastBuildDate>Fri, 30 Oct 2015 20:03:34 +0800</lastBuildDate>
    <generator>Jekyll v2.5.3</generator>
    
      <item>
        <title>JavaScript闭包理解</title>
        <description>&lt;blockquote&gt;
  &lt;p&gt;闭包这个问题一直以来比较生涩，今天一个同事给了他的理解：闭包就是防止全局变量污染。&lt;br /&gt;
  然后我专门上网查了下，总结了以下几点&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;闭包定义&lt;/h2&gt;
&lt;p&gt;闭包通俗点说就是能够读取其他函数内部变量的函数（是指有权访问另一个函数作用域中的变量的函数，创建闭包的最常见的方式就是在一个函数内创建另一个函数，通过另一个函数访问这个函数的局部变量&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;闭包的好处&lt;/h2&gt;
&lt;p&gt;1.希望一个变量长期驻扎在内存中&lt;br /&gt;
  2.避免全局变量的污染&lt;br /&gt;
  3.私有成员的存在&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;理解最深的就是避免全局变量的污染，通俗点说就是相同的变量互不干扰。比如我们定义了一个全局变量，在同一个函数里面又定义了多个和全局相同的变量，通常这种情况会导致全局变量会出错，但是引用闭包后就不会出现这种情况。&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 25 Oct 2015 04:30:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/10/25/JS-bibao/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/10/25/JS-bibao/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>JavaScript事件冒泡、事件委托和阻止事件</title>
        <description>&lt;h2 id=&quot;section&quot;&gt;事件冒泡&lt;/h2&gt;
&lt;p&gt;什么是“事件冒泡”呢？假设这里有一杯水，水被用某种神奇的方式分成不同颜色的几层。&lt;br /&gt;
  这时，从最底层冒出了一个气泡，气泡会一层一层地上升，直到最顶层。而你不管在水的&lt;br /&gt;
  哪一层观察都可以看到并捕捉到这个气泡。好了，把“水”改成“DOM”，把“气泡”改成“事件”。&lt;br /&gt;
  这就是“事件冒泡”。&lt;/p&gt;

&lt;p&gt;在网上查找了一个&lt;a href=&quot;http://www.pureweber.com/works/demos/js-event-delegation/event-bubble.html&quot;&gt;demo&lt;/a&gt;&lt;br /&gt;
  代码如下：&lt;/p&gt;

&lt;p&gt;CSS&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  .white{background-color:#fff;}
  .d-1{width:400px;height:400px;border:1px solid #000;margin:50px 50px;}
  .d-2{width:300px;height:300px;border:1px solid #000;margin:50px 50px;}
  .d-3{width:200px;height:200px;border:1px solid #000;margin:50px 50px;}
  .d-4{width:100px;height:100px;border:1px solid #000;margin:50px 50px;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;HTML&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;div id=&quot;d1&quot; class=&quot;white d-1&quot;&amp;gt;
      &amp;lt;div id=&quot;d2&quot; class=&quot;white d-2&quot;&amp;gt;
          &amp;lt;div id=&quot;d3&quot; class=&quot;white d-3&quot;&amp;gt;
               &amp;lt;div id=&quot;d4&quot; class=&quot;white d-4&quot;&amp;gt;&amp;lt;/div&amp;gt;
          &amp;lt;/div&amp;gt;
       &amp;lt;/div&amp;gt;
 &amp;lt;/div&amp;gt;
 &amp;lt;button id=&quot;reset1&quot;&amp;gt;重置&amp;lt;/button&amp;gt; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; jQuery(&#39;#d4&#39;).click(function(){jQuery(this).css(&#39;background-color&#39;, &#39;yellow&#39;)});
 jQuery(&#39;#d3&#39;).click(function(){jQuery(this).css(&#39;background-color&#39;, &#39;green&#39;)});
 jQuery(&#39;#d2&#39;).click(function(){jQuery(this).css(&#39;background-color&#39;, &#39;blue&#39;)});
 jQuery(&#39;#d1&#39;).click(function(){jQuery(this).css(&#39;background-color&#39;, &#39;red&#39;)});
 jQuery(&#39;#reset1&#39;).click(function(){jQuery(&#39;.white&#39;).css(&#39;background-color&#39;, &#39;#fff&#39;)});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;点击最小的那个，外面所有的都会被上色。你会发现，点击里层的正方形，外层所有的正方形都会被上色。&lt;br /&gt;
  因为它们也都捕捉到了点击事件。看，他们抓到“气泡”了！&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;事件委托&lt;/h2&gt;
&lt;p&gt;修改上面的程序，使用事件委托来处理点击事件。当最顶层捕获点击事件时，查看事件来源于哪一层，然后只将那一层涂色。&lt;br /&gt;
  再次点击每一层，查看实际效果。只有当前点击的正方形变色了，其他的都毫无反应。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  jQuery(&#39;#d1&#39;).click(function(e){
    var t = jQuery(e.target);
    var id = t.attr(&#39;id&#39;);
    if (id===&#39;d4&#39;){
            t.css(&#39;background-color&#39;, &#39;yellow&#39;);
    } else if (id===&#39;d3&#39;) {
            t.css(&#39;background-color&#39;, &#39;green&#39;);
    } else if (id===&#39;d2&#39;) {
            t.css(&#39;background-color&#39;, &#39;blue&#39;);
    } else {
            t.css(&#39;background-color&#39;, &#39;red&#39;);
    } });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当然，如果你有这样嵌套的页面元素，使用了事件委托，委托到了最顶层，这时需要注意：如果其中某个元素，你不希望它的事件冒泡，&lt;br /&gt;
  那么可以使用某种方式阻止事件的冒泡。在jQuery框架中，可以使用stopPropagation()方法来实现而不必关心浏览器兼容性。&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $(&#39;#bind&#39;).click(function(){
    if ($(this).is(&#39;:checked&#39;)) {
        $(&#39;#d4&#39;).bind(&#39;click&#39;, function(e){
            e.stopPropagation();
            alert(&#39;冒泡被阻止，这块将不会改变颜色&#39;);
        });
    } else {
        $(&#39;#d4&#39;).unbind(&#39;click&#39;);
    }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-2&quot;&gt;阻止事件&lt;/h2&gt;
&lt;p&gt;w3c 的方法是 e.preventDefault()，IE 则是使用 e.returnValue = false;&lt;br /&gt;
  在支持 addEventListener() 的浏览器中，也能通过调用时间对象的 preventDefault() 方法取消时间的默认操作。&lt;br /&gt;
  不过，在 IE9 之前的 IE 中，可以通过设置事件对象的 returnValue 属性为 false 来达到同样的效果。&lt;br /&gt;
  下面的代码假设一个事件处理程序，它使用全部的三种取消技术：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  function cancelHandler(event){  
    var event = event || window.event;  //用于IE  
    if(event.preventDefault) event.preventDefault();  //标准技术  
    if(event.returnValue) event.returnValue = false;  //IE  
    return false;   //用于处理使用对象属性注册的处理程序  
  }  
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;当前的 DOM 事件模型草案定义了 Event 对象属性 defaultPrevented。javascript 的 return false 只会阻止默认行为，而是用 jQuery 的话则既阻止默认行为又防止对象冒泡。&lt;/p&gt;
</description>
        <pubDate>Sat, 24 Oct 2015 22:13:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/10/24/JS-event-bubbles-prevent-delegate/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/10/24/JS-event-bubbles-prevent-delegate/</guid>
        
        <category>JavaScript</category>
        
        
      </item>
    
      <item>
        <title>css书写规范、顺序</title>
        <description>&lt;h2 id=&quot;css&quot;&gt;css书写顺序&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;1.位置属性（postion、top、right、z-index、display、float等）&lt;br /&gt;
  2.大小（width、height、padding、margin等）&lt;br /&gt;
  3.文字系列（font、line-height、letter-sapce等）&lt;br /&gt;
  4.背景（background、border等）&lt;br /&gt;
  5.其他（animation、transtion等）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;css-1&quot;&gt;css样式表文件命名&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;em&gt;主要的 master.css&lt;br /&gt;
　&lt;/em&gt;模块 module.css&lt;br /&gt;
　&lt;em&gt;基本共用 base.css&lt;br /&gt;
　&lt;/em&gt;布局、版面 layout.css&lt;br /&gt;
　&lt;em&gt;主题 themes.css&lt;br /&gt;
　&lt;/em&gt;专栏 columns.css&lt;br /&gt;
　&lt;em&gt;文字 font.css&lt;br /&gt;
　&lt;/em&gt;表单 forms.css&lt;br /&gt;
　&lt;em&gt;补丁 mend.css&lt;br /&gt;
　&lt;/em&gt;打印 print.css&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;section&quot;&gt;其他&lt;/h2&gt;
&lt;p&gt;class和id命名要简洁并表明含义&lt;br /&gt;
   详细可参考：&lt;a href=&quot;http://nec.netease.com/standard/css-sort.html&quot;&gt;http://nec.netease.com/standard/css-sort.html&lt;/a&gt;&lt;/p&gt;
</description>
        <pubDate>Fri, 16 Oct 2015 17:20:00 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/10/16/css-specifications/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/10/16/css-specifications/</guid>
        
        <category>CSS</category>
        
        
      </item>
    
      <item>
        <title>parent()、parents()、closest()的区别</title>
        <description>&lt;p&gt;&lt;img src=&quot;http://7xnl4q.com1.z0.glb.clouddn.com/post-bg-jquery-classfication.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;区别&lt;/h2&gt;

&lt;pre&gt;&lt;code&gt;1.parent()方法从指定类型的直接父节点开始查找，在&quot;0&quot;中， &amp;lt;a&amp;gt; 的直接父节点是&amp;lt;li&amp;gt;所以在这里找不到&amp;lt;ul&amp;gt;父节点。在&quot;2&quot;中先找到了&amp;lt;li&amp;gt;，接着找到&amp;lt;ul&amp;gt;，并将它的背景色设置为yellow。parent()返回一个节点。   
 
2.parents()方法查找方式同parent()方法类似，不同的一点在于，当它找到第一的父节点时并没有停止查找，而是继续查找，最后返回多个父节点，如在&quot;2&quot;中，使得id为menu的ul整个背景色变成了yellow。      
  
3.closest()方法查找时从包含自身的节点找起，它同parents()很类似，不同点就在于它只返回一个节点如在&quot;3&quot;中，实现的功能同1相同。但它使得代码量减小，同&quot;2&quot;相比又只返回单一的一个节点。可见，closest()方法在项目中的使用频率是比较大的。
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;section-1&quot;&gt;寻找子节点和兄弟节点&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;children(expr) //查找所有子元素，只会找到直接的孩子节点，不会返回所有子孙&lt;/li&gt;
  &lt;li&gt;contents() //查找下面的所有内容，包括节点和文本。&lt;/li&gt;
  &lt;li&gt;prev() //查找上一个兄弟节点，不是所有的兄弟节点&lt;/li&gt;
  &lt;li&gt;prevAll() //查找所有之前的兄弟节点&lt;/li&gt;
  &lt;li&gt;next() //查找下一个兄弟节点，不是所有的兄弟节点&lt;/li&gt;
  &lt;li&gt;nextAll() //查找所有之后的兄弟节点&lt;/li&gt;
  &lt;li&gt;siblings() //查找兄弟节点，不分前后&lt;/li&gt;
  &lt;li&gt;find() //会在div元素内 寻找 class为classname的元素。(子元素找)&lt;/li&gt;
  &lt;li&gt;filter() //则是筛选div的class为classname的元素。(平级找)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 15 Oct 2015 04:52:42 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/10/15/jquery-parent()-parents()-closest()/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/10/15/jquery-parent()-parents()-closest()/</guid>
        
        <category>Jquery</category>
        
        
      </item>
    
      <item>
        <title>我的第一篇博文</title>
        <description>&lt;p&gt;这是我的第一篇博文&lt;/p&gt;

</description>
        <pubDate>Thu, 01 Oct 2015 22:46:42 +0800</pubDate>
        <link>https://dandanzhou.github.io/2015/10/01/my-first-blog/</link>
        <guid isPermaLink="true">https://dandanzhou.github.io/2015/10/01/my-first-blog/</guid>
        
        <category>Others</category>
        
        
      </item>
    
  </channel>
</rss>
